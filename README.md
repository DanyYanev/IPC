# IPC
Homework for guest lectures software engineering class @elsys 2017

## Task

За 3:
  Два процеса, комуникиращи през named pipe (също така назоваван като FIFO).
  Първи процес - пише “нещо” в цикъл в pipe - може да са случайни числа, стрингове, каквото и да е.
  Втори процес - чете това, което първия процес пише в pipe-а, и го принтира на стандартния изход.
  Няма изискване процесите да спират автоматично.
  Начина за създаване на named pipe файла е по ваш избор.
  Hardcore-нати имена на файлове са ОК.
  Неща, които биха ви трябвали - open, read, write, printf, mkfifo(up to you дали ще се ползва през shell или процесите )… надявам се да не виждам двойки :)

За 4, 5, 6:
  Бързо обяснение за що е то цикличен буфер - буфер (някаква заделена памет), в който нови данни се пишат на края на старите. Особеността е, че като се стигне до “края” на буфера, новите данни почват да се пишат от началото (ефективно се презаписват старите данни).
  https://en.wikipedia.org/wiki/Circular_buffer
  Не е задължително цикличния буфер да е със “позиции” със фиксиран размер, но няма нужда да се опитвате да го усложнявате.

За 4:
  Два процеса, комуникиращи през цикличен буфер, използващ shared memory.
  Първи процес - пише “нещо” в цикличния буфер.
  Втори процес - чете същото “нещо” от цикличния буфер, и го принтира на стандартния изход.
  След като е стартиран, процес 2 не трябва да пропуска нещо новозаписано от процес 1.
  Процес 2 трябва да почва да чете данни от буфера, които реално са записани от процес 1. Пояснение - ако процес 1 още не е “превъртял” (изминал поне един път) цикличния буфер, 
  то частта от буфера, през която процес 1 не е минал, то буфера е частично непълен.
  Sleep фунциите (sleep, nanosleep) са позволени и за двата процеса.
  Какво би трябвало да ползвате - shm_open, mmap, volatile променливи.

За 5+:
  Подобно на 4.
  Два процеса, комуникиращи през цикличен буфер, използващ shared memory.
  Използват се функциите generate и verify от header file-а на предоставения архив.
  -Generate пише блок със информация, зависеща от seed променливата.
  -Verify чете блок, верифицира дали блока е консистентен, и връща seed променливата, с която е генериран (или -1 ако забележи неконсистенция).
  -Generate е значително по-бавна за изпълнение от Verify.
  Първи процес - пише в цикличния буфер, използвайки generate. Seed променливата трябва да се променя при всяко викане на функцията. Използването на sleep-like функции за първия процес е забранено - Generate нарочно отнема повече време от verify :)
  Втори процес - чете от цикличния буфер, използвайки verify.
  След като е стартиран, процес 2 не трябва да пропуска нещо новозаписано от процес 1.
  Процес 2 трябва да почва да чете данни от буфера, които реално са записани от процес 1. Пояснение - ако процес 1 още не е “превъртял” (изминал поне един път) цикличния буфер, то частта от буфера, през която процес 1 не е минал, то буфера е частично непълен.
  Синхронизацията трябва да е така направена, че процес 2 да може да разбере ако процес 1 е прескочил позицията на процес 2 (т.е. че p1 е изпреварил p2 със една обиколка на буфера).
  Начинът по който процес 1 избира последователно Seed променливата трябва да бъде детерминистичен - ако се знае seed за един блок, то трябва да е ясна поредицата от променливи за следващите блокове. Пример - всеки следващ се увеличава с 1, използва pseudorandom функция със seed -предишния блок... Следователно, процес 2 трябва да верифицира последователността на seed променливите (това е причината verify да връща seed-а на блока памет).
  Sleep фунциите (sleep, nanosleep) са позволени и за двата процеса.
  EDIT: Sleep функциите са позволени само за reader процеса.
  Какво би трябвало да ползвате - shm_open, mmap, volatile променливи, generate и verify от предоставените файлове.

  Hints:

  buffer size: 512 blocks
  process 1 write position: 1337
  ...process 1 is writing where...?

  64bit unsigned integer... ;)
